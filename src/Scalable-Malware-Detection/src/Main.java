import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;


import org.mozilla.javascript.Parser;
import org.mozilla.javascript.EvaluatorException;
import org.mozilla.javascript.ast.AstRoot;

/*
 * "Exception in thread "main" java.util.MissingResourceException: 
 * Can't find bundle for base name org.mozilla.javascript.resources.Messages, 
 * locale en_US" means one of the JavaScript files had a "let", "with", "yield"
 * statement.
 */
public class Main 
{	
	/**
	 * 
	 * @param features
	 * @param file
	 * @throws IOException
	 */
	private static void logLevelFeatures(Map<String, ArrayList<String>> features, 
										 	File file) throws IOException
	{
		PrintWriter outFile = new PrintWriter(new FileWriter(file));
		
		for(Map.Entry<String, ArrayList<String>> entry : features.entrySet())
		{
			outFile.println(entry.getKey());
			for(String text : entry.getValue())
				outFile.println("\t" + text);
			
			outFile.println();
		}
		
		outFile.close();
	}
	
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws IOException, 
											ClassNotFoundException  
	{	
		if(args.length != 3)
		{
			System.err.println("Usage is as follows: \"java Main " +
					"<input directory> <output directory> <mode>\"");
			return;
		}
		
		String extractionDirName = args[1];
		File extractionDir = new File(extractionDirName);
		String DELIMITER = " # END OF FEATURE #";
		try
		{
		    if(!extractionDir.exists())
		    	extractionDir.mkdirs();
		}
		catch(Exception e)
		{
			System.err.println("Could not create \"" + extractionDirName + 
					"\" directory");
		}
		
		File flat = new File(extractionDirName + "/Flat-Level.log");
		File oneLevel = new File(extractionDirName + "/One-Level.log");
		File nLevel = new File(extractionDirName + "/N-Level.log");			
		
		File jsFileDirPath;
		
		
		jsFileDirPath = new File(args[0]);
		
		if(!jsFileDirPath.isDirectory())
		{
			System.err.println(args[0] + " is not a directory");
			return;
		}
		
		double startTime = System.currentTimeMillis() / 1000.0;
		
		System.out.println("Now extracting features...\n");
		Map<String, Integer> featureCount = 
				new LinkedHashMap<String, Integer>();
		ArrayList<String> featureList = new ArrayList<String>();
		int maliciousUniques = 0, benignUniques = 0;
		
		try 
		{
			PrintWriter outFile = new PrintWriter(new BufferedWriter(
					new FileWriter(flat)));
			PrintWriter outFileCsv = new PrintWriter(new BufferedWriter(
					new FileWriter(extractionDirName + "/Flat-Level-Count.csv")));
			
			//Get all directories in current dir
			String[] directories = jsFileDirPath.list(new FilenameFilter() {
				  @Override
				  public boolean accept(File dir, String name) {
				    return new File(dir, name).isDirectory();
				  }
				});
			Arrays.sort(directories);
			
			for(String strDir : directories)
			{
				File directory = new File(jsFileDirPath, strDir);
				FeatureExtractor fe = new FeatureExtractor();
				
				for(File file : directory.listFiles()) 
				{
					System.out.println("Extracting from " + file);
					Reader reader = new FileReader(file);
					AstRoot root;
					
					try
					{
						root = new Parser().parse(
								reader, file.getName(), 1);									
						root.visit(fe);
					}
					catch (EvaluatorException e)
					{
						System.err.println("Error on: " + file);
					}
											
					reader.close();
				}
				
				//outFile.println("START OF NEW WEB PAGE");
				//First char of dir is (M/B)
				char urlClass = strDir.charAt(0);
				if(urlClass == 'M')
				{
					outFileCsv.print("0,");
				}
				else if(urlClass == 'B')
				{
					outFileCsv.print("1,");
				}
				else
				{
					System.err.println("First of char of dir neither 'M' nor" +
							"'B'");
				}
				
				
				for(String feature : fe.getFlatLevelFeatures())
				{
					if(!featureCount.containsKey(feature))
					{
						featureList.add(feature);
						// Add new feature to map
						featureCount.put(feature, 1);
						
						if(urlClass == 'M')
						{
							maliciousUniques++;
						}
						else if(urlClass == 'B')
						{
							benignUniques++;
						}
						else
						{
							System.err.println("urlClass not defined!");
						}
					}
					// If feature is already present, then increment counter
					else
					{
						featureCount.put(feature, 
								featureCount.get(feature) + 1);
					}

				}
				
				for(String feature : featureList)
				{
					outFileCsv.print(featureCount.get(feature) + ",");
					featureCount.put(feature, 0); //Clear value for next URL 
				}
				outFileCsv.println();
				
				fe.clearFlatLevelFeatures();
				
				logLevelFeatures(fe.getOneLevelFeatures(), oneLevel);
				fe.clearOneLevelFeatures();
				
				logLevelFeatures(fe.getNLevelFeatures(), nLevel);
				fe.clearNLevelFeatures();
				System.out.println("Finished extracting from " + strDir + "\n");
				
			}
			outFileCsv.close();
			
			// Output features in order of list
			for(String feature : featureList)
			{
				outFile.println(feature + DELIMITER);
			}
			
			outFile.close();
		}
		catch(IOException e)
		{
			System.err.println("File IO Error");
			e.printStackTrace();
		}
		catch(Exception e)
		{
			System.err.println("Error Parsing the AST");
			e.printStackTrace();
		}	
		
		System.out.println("Extraction is finished\n");
		System.out.println("Benign Uniques: " + benignUniques);
		System.out.println("Malicious Uniques: " + maliciousUniques);
		System.out.println("Total Uniques: " + featureList.size());
		double timeAtExtractionFinish = System.currentTimeMillis() / 1000.0;
		double extractionTime = timeAtExtractionFinish - startTime;
		System.out.println("\nTime it took to finish extracting features: " +
							extractionTime / 60 + " minutes\n");
		
		/*
		Scanner inFile;
		String userOption = args[2];
		File hashMapSerFile = new File(extractionDirName + "/hashmap.ser");
		
		if(userOption.equalsIgnoreCase("-a"))
		{
			if(!hashMapSerFile.exists())
			{
				System.out.println("Cannot find ser file for hash map!");
				return;
			}
			FileInputStream fis = new FileInputStream(hashMapSerFile);
			ObjectInputStream ois = new ObjectInputStream(fis); 
			
			featureCount = (LinkedHashMap<String,Integer>) ois.readObject();
			ois.close();
		}
		else if(userOption.equalsIgnoreCase("-n"))
		{			
			
		}
		else
		{
			System.out.println("\nPlease provide correct arguments (-a or -n)");
			return;
		}
		
		//Count the occurrences of features!
		int count = 0;
		try 
		{
			//inFile = new Scanner(new File(extractionDirName + "/Flat-Level.log"));
			char type = 2;
			String currToken = "";
			
			/*
			 
			  
			Populate the hashmap with all features found in every file
			System.out.println("Initializing hash map");
			while(inFile.hasNextLine())
			{
				currToken = inFile.nextLine();
				
				if(currToken.equals("START OF NEW WEB PAGE"))
				{
					System.out.println("Reading features from web page #"
									+ ++count);
					inFile.nextLine(); //Skip (M/B)
				}
				else if(!featureCount.containsKey(currToken))
				{
					featureCount.put(currToken, 0);
				}
			}
			
			System.out.println("\nCounting features");
			inFile = new Scanner(new File(extractionDirName + "/Flat-Level.log"));
			PrintWriter outFile = new PrintWriter(new BufferedWriter(
					new FileWriter(extractionDirName + "/Flat-Level-Count.csv")));
			int webPageCount = 0;
			count = 0;
						
			//Prepopulate with ARFF headers
			/*
			outFile.println("@RELATION \"Flat-Level Feature Extraction\"\n");
			for(int i = 0; i < featureCount.size(); i++)
			{
				outFile.println("@ATTRIBUTE F" + i + " NUMERIC");
			}
			outFile.println("\n@DATA");
			
			// Count the number of occurrences in each feature
			while(inFile.hasNextLine())
			{
				currToken = inFile.nextLine();
				count++;
				
				if(currToken.equals("START OF NEW WEB PAGE"))
				{
					System.out.println("Reading features from web page #" 
								+ ++webPageCount);
					
					if(count > 1)
					{
						Iterator<Entry<String, Integer>> iter = 
								featureCount.entrySet().iterator();
						 
						//Log all feature counts from file
						while(iter.hasNext()) 
						{
							Map.Entry<String, Integer> mEntry = 
									(Map.Entry<String, Integer>) iter.next();
							outFile.print(mEntry.getValue() + ",");
						}
						
						iter = featureCount.entrySet().iterator();

						//Clear values before moving to next file 
						while(iter.hasNext()) 
						{
							Map.Entry<String, Integer> mEntry = 
									(Map.Entry<String, Integer>) iter.next();
							mEntry.setValue(0);
						}
						
						if(type == 'B')
							outFile.print(1);
						else if(type == 'M')
							outFile.print(0);
						else
							outFile.print(2);
						
						outFile.println();
					}
					
					type = inFile.nextLine().charAt(0); //Assign new (M/B)					
				}
				else 
				{/*
					//Increment count of feature
					Iterator<Entry<String, Integer>> iter = 
							featureCount.entrySet().iterator();
					 
					//Log all feature counts from file
					while(iter.hasNext()) 
					{
						Map.Entry<String, Integer> mEntry = 
								(Map.Entry<String, Integer>) iter.next();
						System.out.print(mEntry.getKey() + ",");
					}
					
					String featureText; 
					if(currToken.contains(DELIMITER))
					{
						//System.out.println(currToken + " contains DELIMITER");
						try
						{
							featureText = currToken.split(DELIMITER)[0];						
						}
						catch (ArrayIndexOutOfBoundsException e)
						{
							//System.out.println("Feature is a space: " +
									//currToken);
							featureText = " ";			
							
						}
						//System.out.println("Actual feature: " + featureText);
					}
					else
					{
						//System.out.println("DELIMITER: " + DELIMITER);
						//System.out.println(currToken + " does not " +
								//"contain DELIMITER");
						
						currToken += "\n" + inFile.nextLine();
						while(!currToken.contains(DELIMITER))
						{
							//System.out.println(currToken + " does not " +
									//"contain DELIMITER");
							currToken += "\n" + inFile.nextLine();
						}
						
						//System.out.println(currToken + " contains DELIMITER");
						featureText = currToken.split(DELIMITER)[0];
						//System.out.println("Actual feature: " + featureText);
					}
							
					
					if(!featureCount.containsKey(featureText))
					{
						System.err.println("Feature: " + featureText + " not " +
								"found in hashmap. Adding it now.");
						featureCount.put(featureText, 0);
					}
					else
					{
						int currFeatureCount = featureCount.get(featureText);
						//System.out.println(featureText + " found!");
						featureCount.put(featureText, currFeatureCount + 1);
					}
						
					/*
					System.out.println(currToken);
					//featureCount.put(currToken, 1);
					System.out.println("hello");
					int featureCnt = featureCount.get("a");
					System.out.println("hello");
					System.out.println(featureCnt);
					
					

				}
			}
			
			Iterator<Entry<String, Integer>> iter = 
					featureCount.entrySet().iterator();
			 
			//Log all feature counts from last file 
			while(iter.hasNext()) 
			{
				Map.Entry<String, Integer> mEntry = 
						(Map.Entry<String, Integer>) iter.next();
				outFile.print(mEntry.getValue() + ",");
			}
			
			iter = featureCount.entrySet().iterator();
			
			//Clear values for last file 
			while(iter.hasNext()) 
			{
				Map.Entry<String, Integer> mEntry = 
						(Map.Entry<String, Integer>) iter.next();
				mEntry.setValue(0);
			}
			
			if(type == 'B')
				outFile.print(1);
			else if(type == 'M')
				outFile.print(0);
			else
				outFile.print(2);
			
			outFile.println("\n");		
			
			outFile.close();
			inFile.close();
		} 
		catch(FileNotFoundException e) 
		{
			System.err.println("Could not find file with extracted features!");
			e.printStackTrace();
		}		        
		
		System.out.println("\nWriting features in order");
		PrintWriter outFile = new PrintWriter(new BufferedWriter(
				new FileWriter(extractionDirName + "/Flat-Level-" +
						"Features-In-CSV-Order.log")));
		
		Iterator<Entry<String, Integer>>  iter = 
				featureCount.entrySet().iterator();
		 
		//Log all feature names to file and add to arraylist
		//ArrayList<String> featureNames = new ArrayList<String>(); 
		while(iter.hasNext()) 
		{
			Map.Entry<String, Integer> mEntry = 
					(Map.Entry<String, Integer>)iter.next();
			String featureName = mEntry.getKey();
			outFile.println(featureName + DELIMITER);
			
			// Truncate feature name at 1000 characters before eventually adding
			// to feature set tree
			/*
			if(featureName.length() > 1000)
				featureName = featureName.substring(0, 1000);
			featureNames.add(featureName);
		}
		outFile.close();
		
		//Write hashmap to serialization file
		FileOutputStream fos = new FileOutputStream(hashMapSerFile); 
		ObjectOutputStream oos = new ObjectOutputStream(fos);
	    oos.writeObject(featureCount);
	    oos.close();
	    
	    double timeAtFeatureCountingFinish = System.currentTimeMillis() 
	    		/ 1000.0;	    
		double countTime = timeAtFeatureCountingFinish - timeAtExtractionFinish;
		System.out.println("Time it took to finish counting features: " +
							countTime / 60 + " minutes\n");		
		
		//Create FeatureSetTree and write to serialization file
		File featureSetTreeFile = new File(extractionDirName 
				+ "/featureSetTree.ser");
		//StateTree featureSetTree = new StateTree(featureNames);
		System.out.println("Skipping creating tree");
		
		FileOutputStream fos2 = new FileOutputStream(featureSetTreeFile); 
		ObjectOutputStream oos2 = new ObjectOutputStream(fos2);
	    //oos2.writeObject(featureSetTree);
	    System.out.println("Skipping writing tree to ser file");
	    oos2.close();
		
	    double timeAtFeatureTreeFinish = System.currentTimeMillis() / 1000.0;	    
		double featureCreationTime = timeAtFeatureTreeFinish 
				- timeAtFeatureCountingFinish;
		System.out.println("Time it took to finish creating feature " +
				"set tree: " + featureCreationTime / 60 + " minutes\n");		
		
		System.out.println("Complete\n");
				
		double timeAtProgramFinish = System.currentTimeMillis() / 1000.0;
		double finishTime = timeAtProgramFinish - startTime;
		System.out.println("Time it took to finish everything: " +
							finishTime / 60 + " minutes\n");
/*        
        PrintWriter outFile;
        StateTree featureSetTree = new StateTree(sampleTexts);    
		try 
		{
			outFile = new PrintWriter(new FileWriter(
							new File("ExtractionLogs/FeatureSetStateTree.log")));				       
	                                 
	        outFile.println(featureSetTree);
	        outFile.close();	            	    
		} 
		catch(IOException e) 
		{
			System.err.println("Could not write the state tree to the log!");
			e.printStackTrace();
		}
		
		System.out.println(featureSetTree);
        System.out.println("Is \"appert\" present in tree: ");
        System.out.println(featureSetTree.isFeaturePresent("appert"));
        System.out.println("Is \"benign\" present in tree: ");
        System.out.println(featureSetTree.isFeaturePresent("benign"));
        System.out.println("Is \"insert\" present in tree: ");
        System.out.println(featureSetTree.isFeaturePresent("insert"));
        System.out.println("Is \"o.SaveToFile(name, 2)\" present in tree: ");
        System.out.println(featureSetTree.isFeaturePresent("o.SaveToFile(name, 2)"));
 */       				
	}
}
